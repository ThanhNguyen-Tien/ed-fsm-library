# Event-Driven - Finite State Machine Library for ARM Cortex-M Series

Welcome to the event-driven library for ARM Cortex-M microcontrollers. This library is designed to simplify the development of event-driven applications, making your embedded systems more efficient and responsive.

## Introduction to Event-Driven Programming

Event-driven programming is a programming paradigm in which the flow of the program is determined by eventsâ€”such as user actions (mouse clicks, key presses), sensor outputs, or messages from other programs or threads. In an event-driven application, there is a main loop that listens for events and dispatches them to appropriate event handlers.

   ### Key Concepts
   
   1. **Event**: An occurrence or action that the system can recognize and respond to. Examples include hardware interrupts, timer overflows, or custom user-defined events.
      
   2. **Event Handler**: A function or method that gets called in response to a specific event. Event handlers contain the logic to process events.
   
   3. **Event Queue**: A data structure that holds events until they are processed by the event handler. Events are usually processed in the order they arrive (FIFO - First In, First Out).
   
   4. **Dispatcher**: A component that listens for events in the event queue and calls the appropriate event handler.

   ### How It Works
   
   The following diagram illustrates the basic workflow of an event-driven system:
   
   ![image](https://github.com/user-attachments/assets/89739d51-996a-4b5d-98b2-9eb4bca0734f)
   
   1. Events are generated by the system, there are 3 sources of events:
      - **Interrupts Events**: Event come from ISR such as GPIO, ADC, UART, SPI, I2C, ... (E1, E2, E4)
      - **Timer Events**: Events come from Timer such as Systick, HardTimer, SoftTimer (E3, E7)
      - **Custom Events**: Events come from another handler function (E5, E6)
   2. Events are pushed into the event queue.
   3. The dispatcher fetches events from the event queue.
   4. The dispatcher invokes the corresponding event handler for each event.
   
   > **Note:** All steps 3 and 4 are performed inside the Engine module.

   ### Advantages
   
   - **Modularity**: Event-driven systems promote modularity by separating event detection from event handling.
   - **Responsiveness**: Systems can respond quickly to asynchronous events.
   - **Scalability**: Easy to add new event types and handlers without affecting existing code.

## Library Features

- **Lightweight**: Designed to be minimal in resource usage, suitable for embedded systems with limited memory and processing power.
- **Flexible**: Supports custom event types and handlers.
- **Efficient**: Optimized for ARM Cortex-M microcontrollers.


## Library Note

- **This library is best used for bare-metal systems, which are systems that do not use an OS.**

- **For MCU (Cortex M) with only 1 core, we only have 1 main loop. EventQueue will be continuously checked in this mainloop through the Engine_Run() function.**

- **If there are no events to handle, the system will perform WAIT FOR INTERRUPT.**

- **Please consider carefully if you intend to use any blocking commands such as HAL_Delay(), while(!UART_Ready()),... or similar because it will affect the EventQueue, delaying the whole system.**

- **Let's make everythings Asynchronous & non-Blocking.**

<p><em><strong><span style="font-size: 1.5em; text-decoration: underline;">Go to Components folder and take a look at README.md to GET STARTED!!!</span></strong></em></p>